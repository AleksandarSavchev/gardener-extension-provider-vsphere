package common

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"time"

	"golang.org/x/oauth2/google"
	"golang.org/x/oauth2/jwt"
)

func GetClient(svcAcctKey map[string]string) *http.Client {
	conf := &jwt.Config{
		Email:      svcAcctKey["client_email"],
		PrivateKey: []byte(svcAcctKey["private_key"]),
		Scopes: []string{
			"https://www.googleapis.com/auth/cloud-platform",
		},
		TokenURL: google.JWTTokenURL,
	}
	client := conf.Client(context.TODO())
	return client
}

// Poll repeatedly makes the http.Request on a http.Client until timeout or a result by the predicate other than Wait.
func Poll[T any](client *http.Client, req *http.Request, timeout time.Duration, predicate func(T) error) error {
	var finish = time.Now().Add(timeout)
	for {
		err, responseBytes := func(client *http.Client, req *http.Request) (error, []byte) {
			rs, err := client.Do(req)
			if err != nil {
				return fmt.Errorf("could not send request: %w", err), nil
			}
			defer rs.Body.Close()

			responseBytes, err := io.ReadAll(rs.Body)
			return err, responseBytes
		}(client, req)
		if err != nil {
			return fmt.Errorf("could not get response body: %w", err)
		}

		var response T
		err = json.Unmarshal(responseBytes, &response)
		if err != nil {
			return fmt.Errorf("could not unmarshal from response body: %w", err)
		}
		err = predicate(response)
		if err != Wait {
			return err
		}

		time.Sleep(time.Minute)
		if time.Now().After(finish) {
			return fmt.Errorf("exhausted timeout of %s while polling", timeout)
		}
	}
}
