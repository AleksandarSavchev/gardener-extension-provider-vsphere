package main

import (
	"bytes"
	"encoding/json"
	"flag"
	"fmt"
	"io"
	"net/http"
	"os"
	"time"

	"github.com/gardener/gardener-extension-provider-vsphere/test/gcve-setup/common"
	gardenerutils "github.com/gardener/gardener/pkg/utils"
	"github.com/go-logr/logr"
	"github.com/pkg/errors"
	"gopkg.in/yaml.v3"
	"sigs.k8s.io/controller-runtime/pkg/log"
	"sigs.k8s.io/controller-runtime/pkg/log/zap"
)

var (
	phase          = flag.String("phase", "", "Phase of this plugin, either [setup,shutdown]")
	serviceAccount = flag.String("service-account", os.Getenv("SERVICEACCOUNT_JSON"), "Service account containing credentials for the GCP API")
	location       = flag.String("location", os.Getenv("LOCATION"), "GCP location such as us-east4a")
	cidr           = flag.String("cidr", os.Getenv("MANAGEMENT_CIDR"), "CIDR for management network")
	cloudId        = flag.String("cloud-id", os.Getenv("CLOUD_ID"), "cloud ID")
	credFile       = flag.String("cred-file", "", "Credential file location")
	logger         logr.Logger
)

func main() {
	opts := zap.Options{}
	opts.BindFlags(flag.CommandLine)
	flag.Parse()

	log.SetLogger(zap.New(zap.UseFlagOptions(&opts)))
	logger = log.Log.WithName("gcve-setup")

	var err error
	if err = validate(); err != nil {
		logger.Error(err, "error validating input flags")
		os.Exit(1)
	}

	startTime := time.Now()
	logger.Info("Starting at:", "time", startTime.String())
	var svcAcctKey map[string]string
	serviceAccountBytes, err := os.ReadFile(*serviceAccount)
	if err != nil {
		logger.Error(err, "Could not read service account key")
		os.Exit(1)
	}
	err = json.Unmarshal(serviceAccountBytes, &svcAcctKey)
	if err != nil {
		logger.Error(err, "Could not unmarshal application credential JSON")
		os.Exit(1)
	}

	if *phase == "setup" {
		err = setupGCVE(svcAcctKey)
	} else if *phase == "shutdown" {
		err = shutdownGCVE(svcAcctKey)
	} else if *phase == "dummy" {
		logger.Info("Dummy invocation")
	}

	if err != nil {
		logger.Error(err, "error in phase processing", "phase", phase)
		os.Exit(1)
	}
	logger.Info("Finishing at", "time", time.Now().String(), "duration", time.Now().Sub(startTime).String())
}

func validate() error {
	if serviceAccount == nil || *serviceAccount == "" {
		return errors.Errorf("--service-account flag must be set")
	}
	if len(*phase) == 0 || (*phase != "setup" && *phase != "shutdown" && *phase != "dummy") {
		return errors.Errorf("--phase flag is `%s' and must be ['setup', 'shutdown', 'dummy']", *phase)
	}
	return nil
}

func setupGCVE(svcAcctKey map[string]string) error {
	logger.Info("setupGCVE()")

	client := common.GetClient(svcAcctKey)

	if *cloudId == "" {
		id, err := gardenerutils.GenerateRandomStringFromCharset(5, "abcdefghijklmnopqrstuvwxyz")
		if err != nil {
			return fmt.Errorf("could not generate name: %w", err)
		}
		cloudId = &id
	}

	projectId := fmt.Sprintf("projects/%s/locations/%s/privateClouds/%s", svcAcctKey["project_id"], *location, *cloudId)
	pc, err := getPrivateCloud(client, projectId)
	if err != nil {
		return err
	}

	var operation *common.Operation
	if pc == nil {
		// create a new PC
		operation, err = getCreateOperation(svcAcctKey["project_id"], client)
	} else {
		// we have an existing PC
		operation, err = lookupOperation(svcAcctKey["project_id"], client)
	}
	if err != nil {
		return err
	}

	if operation != nil {
		err = pollResponse(operation, client, func(p *common.Operation) error {
			if p.Done && p.Response["state"] == common.ACTIVE {
				return nil
			} else {
				return common.Wait
			}
		})

		if err != nil {
			return fmt.Errorf("error polling response: %w", err)
		}
	}

	if *credFile != "" {
		f, err2 := os.Create(*credFile)
		if err2 != nil {
			return fmt.Errorf("error creating credentials file: %w", err2)
		}
		err = outputCreds(client, projectId, f)
		_ = f.Close()
	}

	return err
}

func shutdownGCVE(svcAcctKey map[string]string) error {
	logger.Info("shutdownGCVE()")
	client := common.GetClient(svcAcctKey)

	pc, err := getPrivateCloud(client, fmt.Sprintf("projects/%s/locations/%s/privateClouds/%s", svcAcctKey["project_id"], *location, *cloudId))
	if err != nil {
		return err
	}

	var operation *common.Operation
	if pc != nil && pc.State == common.PURGING {
		return nil
	}

	url := fmt.Sprintf("https://vmwareengine.googleapis.com/v1/projects/%s/locations/%s/privateClouds/%s?force=true&delayHours=0", svcAcctKey["project_id"], *location, *cloudId)
	req, err := http.NewRequest("DELETE", url, nil)
	if err != nil {
		return fmt.Errorf("failure to create request: %w", err)
	}

	resp, err := client.Do(req)
	if err != nil {
		return fmt.Errorf("transport error deleting from /privateClouds: %w", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode >= 300 {
		body, _ := io.ReadAll(resp.Body)
		return fmt.Errorf("unexpected response posting to /privateClouds: %d, %s", resp.StatusCode, body)
	}

	operation, err = parseOperation(resp)
	if err != nil {
		return err
	}

	return pollResponse(operation, client, func(p *common.Operation) error {
		if p.Done && p.Response["state"] == common.DELETED {
			return nil
		} else {
			return common.Wait
		}
	})
}

func getCreateOperation(projectId string, client *http.Client) (*common.Operation, error) {
	pc := &common.PrivateCloud{
		ManagementCluster: common.ManagementCluster{
			NodeCount:  3,
			ClusterId:  *cloudId,
			NodeTypeId: "standard-72",
		},
		NetworkConfig: common.NetworkConfig{
			ManagementCidr:      *cidr,
			VmwareEngineNetwork: fmt.Sprintf("projects/%s/locations/global/vmwareEngineNetworks/default", projectId),
		},
	}

	b, err := json.Marshal(pc)
	if err != nil {
		return nil, fmt.Errorf("could not marshall PrivateCloud: %w", err)
	}

	url := fmt.Sprintf("https://vmwareengine.googleapis.com/v1/projects/%s/locations/%s/privateClouds?privateCloudId=%s", projectId, *location, *cloudId)
	resp, err := client.Post(url, "application/json", bytes.NewReader(b))
	if err != nil {
		return nil, fmt.Errorf("transport error posting to /privateClouds: %w", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode >= 300 {
		body, _ := io.ReadAll(resp.Body)
		return nil, fmt.Errorf("unexpected response posting to /privateClouds: %d, %s", resp.StatusCode, body)
	}
	return parseOperation(resp)
}

func lookupOperation(projectId string, client *http.Client) (*common.Operation, error) {
	req, err := http.NewRequest("GET", fmt.Sprintf("https://vmwareengine.googleapis.com/v1/projects/%s/locations/%s/operations", projectId, *location), nil)
	if err != nil {
		return nil, fmt.Errorf("failure to create request: %w", err)
	}
	resp, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("failure to send reqest: %m", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode >= 300 {
		body, _ := io.ReadAll(resp.Body)
		return nil, fmt.Errorf("unexpected response posting to /operations: %d, %s", resp.StatusCode, body)
	}

	responseBytes, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("could not read from response body: %w", err)
	}
	response := &common.List[common.Operation]{}
	err = json.Unmarshal(responseBytes, &response)
	if err != nil {
		return nil, fmt.Errorf("could not parse response body: %w", err)
	}
	operationName := fmt.Sprintf("projects/%s/locations/%s/privateClouds/%s", projectId, *location, *cloudId)
	for _, op := range response.Items {
		if op.Metadata["target"] == operationName && !op.Done {
			return &op, nil
		}
	}
	return nil, nil
}

func pollResponse[T common.HasError](operation *common.Operation, client *http.Client, predicate func(p T) error) error {
	// poll on the operation for completion
	req, err := http.NewRequest("GET", "https://vmwareengine.googleapis.com/v1/"+operation.Name, nil)
	if err != nil {
		return fmt.Errorf("failure to create request: %w", err)
	}

	return common.Poll(client, req, 3*time.Hour, predicate)
}

func parseOperation(resp *http.Response) (*common.Operation, error) {
	// recover the returned operation
	responseBytes, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("could not read from response body: %w", err)
	}
	result := &common.Operation{}
	err = json.Unmarshal(responseBytes, &result)
	if err != nil {
		return nil, fmt.Errorf("could not unmarshal from response body: %w", err)
	}
	return result, err
}

func outputCreds(client *http.Client, projectId string, writer io.Writer) error {
	privateCloud, err := getPrivateCloud(client, projectId)
	if err != nil {
		return err
	}

	nsxCredentials, err := getCredentials(client, projectId, "NsxCredentials")
	if err != nil {
		return err
	}
	vcenterCredentials, err := getCredentials(client, projectId, "VcenterCredentials")
	if err != nil {
		return err
	}

	results := common.RunResults{
		PrivateCloud:       *privateCloud,
		NsxCredentials:     *nsxCredentials,
		VcenterCredentials: *vcenterCredentials,
	}

	b, err := yaml.Marshal(results)
	if err != nil {
		return fmt.Errorf("failure to marshal results: %w", err)
	}
	_, err = writer.Write(b)
	if err != nil {
		return fmt.Errorf("failure to write output: %w", err)
	}
	return nil
}

func getCredentials(client *http.Client, projectId string, credType string) (*common.Credentials, error) {
	url := "https://vmwareengine.googleapis.com/v1/" + projectId + ":show" + credType
	req, err := http.NewRequest("GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("failure to create request: %w", err)
	}
	resp, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("failure to send reqest: %m", err)
	}
	defer resp.Body.Close()

	body, _ := io.ReadAll(resp.Body)
	if resp.StatusCode >= 300 {
		return nil, fmt.Errorf("unexpected response posting to %s: %d, %s", url, resp.StatusCode, body)
	}
	credential := &common.Credentials{}
	err = json.Unmarshal(body, credential)
	if err != nil {
		return nil, fmt.Errorf("failure to send reqest: %m", err)
	}
	return credential, nil
}

func getPrivateCloud(client *http.Client, projectId string) (*common.PrivateCloud, error) {
	req, err := http.NewRequest("GET", "https://vmwareengine.googleapis.com/v1/"+projectId, nil)
	if err != nil {
		return nil, fmt.Errorf("failure to create request: %w", err)
	}
	resp, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("failure to send reqest: %m", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode >= 300 {
		return nil, nil
	}

	responseBytes, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("could not read from response body: %w", err)
	}

	response := &common.PrivateCloud{}
	err = json.Unmarshal(responseBytes, &response)

	return response, err
}
