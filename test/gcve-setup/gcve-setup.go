package main

import (
	"bytes"
	"encoding/json"
	"flag"
	"fmt"
	"io"
	"net/http"
	"os"
	"time"

	"github.com/gardener/gardener-extension-provider-vsphere/test/gcve-setup/common"
	gardenerutils "github.com/gardener/gardener/pkg/utils"
	"github.com/go-logr/logr"
	"github.com/pkg/errors"
	"sigs.k8s.io/controller-runtime/pkg/log"
	"sigs.k8s.io/controller-runtime/pkg/log/zap"
)

var (
	phase          = flag.String("phase", "", "Phase of this plugin, either [setup,shutdown]")
	serviceAccount = flag.String("service-account", os.Getenv("SERVICEACCOUNT_JSON"), "Service account containing credentials for the GCP API")
	location       = flag.String("location", os.Getenv("LOCATION"), "GCP location such as us-east4a")
	cidr           = flag.String("cidr", os.Getenv("MANAGEMENT_CIDR"), "CIDR for management network")
	cloudId        = flag.String("cloud-id", os.Getenv("CLOUD_ID"), "cloud ID")
	generateCreds  = flag.Bool("generate-creds", false, "Output credentials JSON")
	logger         logr.Logger
)

func main() {
	opts := zap.Options{}
	opts.BindFlags(flag.CommandLine)
	flag.Parse()

	log.SetLogger(zap.New(zap.UseFlagOptions(&opts)))
	logger = log.Log.WithName("gcve-setup")

	var err error
	if err = validate(); err != nil {
		logger.Error(err, "error validating input flags")
		os.Exit(1)
	}

	startTime := time.Now()
	logger.Info("Starting at:", "time", startTime.String())
	var svcAcctKey map[string]string
	err = json.Unmarshal([]byte(*serviceAccount), &svcAcctKey)
	if err != nil {
		logger.Error(err, "Could not unmarshal application credential JSON")
		os.Exit(1)
	}

	if *phase == "setup" {
		err = setupGCVE(svcAcctKey)
	} else if *phase == "shutdown" {
		err = shutdownGCVE(svcAcctKey)
	} else if *phase == "dummy" {
		logger.Info("Dummy invocation")
	}

	if err != nil {
		logger.Error(err, "error in phase processing", "phase", phase)
		os.Exit(1)
	}
	logger.Info("Finishing at", "time", time.Now().String, "duration", time.Now().Sub(startTime).String())
}

func validate() error {
	if len(*phase) == 0 || (*phase != "setup" && *phase != "shutdown" && *phase != "dummy") {
		return errors.Errorf("--phase flag is `%s' and must be ['setup', 'shutdown', 'dummy']", *phase)
	}
	return nil
}

func setupGCVE(svcAcctKey map[string]string) error {
	logger.Info("setupGCVE()")

	client := common.GetClient(svcAcctKey)

	if cloudId == nil {
		id, err := gardenerutils.GenerateRandomStringFromCharset(5, "abcdefghijklmnopqrstuvwxyz")
		if err != nil {
			return fmt.Errorf("could not generate name: %w", err)
		}
		cloudId = &id
	}

	pc := &common.PrivateCloud{
		ManagementCluster: common.ManagementCluster{
			NodeCount:  "3",
			ClusterId:  *cloudId,
			NodeTypeId: "standard-72",
		},
		NetworkConfig: common.NetworkConfig{
			ManagementCidr:      *cidr,
			VmwareEngineNetwork: fmt.Sprintf("projects/%s/locations/global/vmwareEngineNetworks/default", svcAcctKey["project_id"]),
		},
	}

	name := fmt.Sprintf("https://vmwareengine.googleapis.com/v1/projects/%s/locations/%s/privateClouds?privateCloudId=%s", svcAcctKey["project_id"], *location, *cloudId)

	b, err := json.Marshal(pc)
	if err != nil {
		return fmt.Errorf("could not marshall PrivateCloud: %w", err)
	}
	resp, err := client.Post(name, "application/json", bytes.NewReader(b))
	if err != nil {
		return fmt.Errorf("transport error posting to /privateClouds: %w", err)
	}
	defer resp.Body.Close()

	err, operation := parseOperation(resp)
	if err != nil {
		return err
	}

	err = pollResponse(operation, client, func(p *common.Operation) error {
		if p.Done && p.Response["state"] == common.ACTIVE {
			return nil
		} else {
			return common.Wait
		}
	})

	if err != nil && *generateCreds {
		name = fmt.Sprintf("projects/%s/locations/%s/privateClouds/%s", svcAcctKey["project_id"], *location, *cloudId)
		err = outputCreds(client, name)
	}

	return err
}

func shutdownGCVE(svcAcctKey map[string]string) error {
	logger.Info("shutdownGCVE()")
	client := common.GetClient(svcAcctKey)
	url := fmt.Sprintf("https://vmwareengine.googleapis.com/v1/projects/%s/locations/%s/privateClouds/%s?force=true&delayHours=0", svcAcctKey["project_id"], *location, *cloudId)
	req, err := http.NewRequest("DELETE", url, nil)
	if err != nil {
		return fmt.Errorf("failure to create request: %w", err)
	}

	resp, err := client.Do(req)
	if err != nil {
		return fmt.Errorf("transport error deleting from /privateClouds: %w", err)
	}
	defer resp.Body.Close()

	err, operation := parseOperation(resp)
	if err != nil {
		return err
	}

	return pollResponse(operation, client, func(p *common.Operation) error {
		if p.Done && p.Response["state"] == common.DELETED {
			return nil
		} else {
			return common.Wait
		}
	})
}

func pollResponse[T common.HasError](operation *common.Operation, client *http.Client, predicate func(p T) error) error {
	// poll on the operation for completion
	req, err := http.NewRequest("GET", "https://vmwareengine.googleapis.com/v1/"+operation.Name, nil)
	if err != nil {
		return fmt.Errorf("failure to create request: %w", err)
	}

	return common.Poll(client, req, 3*time.Hour, predicate)
}

func parseOperation(resp *http.Response) (error, *common.Operation) {
	// recover the returned operation
	responseBytes, err := io.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("could not read from response body: %w", err), nil
	}
	result := &common.Operation{}
	err = json.Unmarshal(responseBytes, &result)
	if err != nil {
		return fmt.Errorf("could not unmarshal from response body: %w", err), nil
	}
	return err, result
}

func outputCreds(client *http.Client, name string) error {
	req, err := http.NewRequest("GET", "https://vmwareengine.googleapis.com/v1/"+name, nil)
	if err != nil {
		return fmt.Errorf("failure to create request: %w", err)
	}
	resp, err := client.Do(req)
	if err != nil {
		return fmt.Errorf("failure to send reqest: %m", err)
	}

	responseBytes, err := io.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("could not read from response body: %w", err)
	}

	println(responseBytes)
	return nil
}
